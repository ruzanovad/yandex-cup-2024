Людвиг ван Бетховен был страстным поклонником произведений Моцарта. В молодости Бетховен стремился подражать его стилю и даже делал свои вариации на темы Моцарта. При этом Бетховен считал, что настоящая ценность вариаций заключается в уважении к источнику, а не в полном его изменении. Но как понять, не слишком ли далеко вариация ушла от оригинала?

**Ваша задача** — создать алгоритм, который будет находить вариации и каверы, наиболее близкие к оригинальной композиции, чтобы, как и Бетховен, музыканты могли вдохновляться великими произведениями прошлого, сохраняя их суть.

# Формат входных данных

Во входных данных задачи есть следующие файлы:

    dataset
        splits
            train_cliques.npy
            val_cliques.npy
            test_ids.npy
        cliques2versions.tsv
        train.zip
        test.zip
    baseline.zip

dataset — директория с данными.

train.zip архив с обучающими данными, разложенными по поддиректориям. Пример пути к обучающему примеру train/1/2/3/195123.npy имена поддиректорий выводятся из id трека, в данном случае 195123 Внутри файла двумерный numpy array который можно прочитать с помощью numpy.load. Это вариация [CQT-спектрограммы](https://en.wikipedia.org/wiki/Constant-Q_transform) сжатой по размерности времени, которую мы строили по 60 секундам взятым из центральной части трека.

test.zip аналогичным образом организованный архив с тестовыми данными.

cliques2versions.tsv содержит отображение из id клики, группы треков являющихся каверами друг друга (формально среди них есть оригинал, но для нашей задачи это неважно) в список треков которые содержатся в этой клике. Данное отображение известно только для обучающего подмножества.

splits — это директория с разбивкой на тест трейн и валидацию.

train_cliques.npy и val_cliques.npy содержат списки клик для обучающего и валидационного подмножества (CQT треков для обоих подмножеств лежат в директории train)

test_ids.npy содержит список id треков тестового подмножества (CQT для которых лежат в test)

Все файлы можно скачать по [ссылке](https://disk.yandex.ru/d/RjMQIusMf6_L4w/dataset)

# Формат решения

Вам необходимо найти по 100 треков (из тестового множества треков, исключая заданный трек), которые наиболее вероятно являются каверами заданного трека. Для каждого трека из тестового множества нужно вывести одну строку в итоговый файл с решением. Формат строки query_trackid [space] trackid1 [space] trackid2 … trackid100

Качество решения мы будем измерять с помощью метрики nDCG@100 (Normalized Discounted Cumulative Gain at K, K=100) В качестве дисконтирующей функции мы используем 1/sqrt(position), т.е. релевантный ответ на первой позиции добавляет 1.0 на второй 0.707 и т.д.

Ссылка на википедию: [Normalized_DCG](https://en.wikipedia.org/wiki/Discounted_cumulative_gain#Normalized_DCG)

# Примечание

Во время соревнования в лидерборде будет отображаться максимальный public score из всех ваших валидных посылок. После завершения соревнования лидерборд будет переранжирован согласно private score вашей последней валидной посылки. Кроме этого в лидерборде будет отображаться public score, посчитанный также по вашему последнему валидному решению. Это означает, что он может не совпадать (в частности быть ниже) с вашим максимальным public score.
